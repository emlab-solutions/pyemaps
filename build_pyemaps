from multiprocessing.sharedctypes import Value
import os
from shutil import move
from pathlib import Path

MAKE_LOOKUP = dict(
    dif = 'DIFPYF',
    bloch = 'BLOCHPYF',
    dpgen = 'CDPOBJ DPGENPYF',
    csf = 'CSFPYF',
    powder = 'POWDERPYF',
    spg = 'SPGSEEKPYF',
    scattering = 'SCTPYF',
    all = 'CDPOBJ ALLPYF'
)

test_pypi_url = "https://test.pypi.org"
rel_pypi_url = "https://pypi.org"
twine_cfg = 'pypi_twine.cfg'
twinetest_cfg = 'testpypi_twine.cfg'

def clean():
    '''
    remove build and dist directory in the pyemaps root directory
    '''
    import os, shutil
    from pathlib import Path
    
    builddir = Path("build")
    print(f"Build dir: {builddir}")
    if os.path.exists(builddir) and os.path.isdir(builddir):
        shutil.rmtree(builddir)


    distdir = Path('dist')
    print(f"Distribution dir: {distdir}")
    if os.path.exists(distdir) and os.path.isdir(distdir):
        shutil.rmtree(distdir)


    eggdir = Path('pyemaps.egg-info')
    print(f"Egg info dir: {eggdir}")
    if os.path.exists(eggdir) and os.path.isdir(eggdir):
        shutil.rmtree(eggdir)

def set_cfg(comp):
    import json, os

    json_cfg = os.getenv('PYEMAPS_JSON')

    if not json_cfg:
        json_cfg = "comp.json" # default

    # write a file recording the comp name for setup consumption
    
    json_obj = json.dumps(dict(component = comp))
    try:
        with open(json_cfg, 'w', encoding="utf-8") as f:
            f.write(json_obj)

    except IOError as e:
        raise ValueError(f"Error writing configuration file {json_cfg} for packaging")


def make_pyf(comp):
    '''
    make .pyf file according to comp name
    '''
    from pathlib import Path
    # first change working directory to emaps from here
    thisfile_dir = Path(os.path.abspath(__file__)).parent.absolute()
    print(f'pyemaps root dir: {thisfile_dir}')

    pyemapsroot = thisfile_dir
    os.chdir(os.path.join(thisfile_dir, 'emaps'))
    emapsdir = os.getcwd()

    os.system("make clean")

    pyf_fname = 'emaps_'
    makestr = "make EMAPSALLMODULES"
    if comp in MAKE_LOOKUP:
        makestr += ' '
        makestr += MAKE_LOOKUP[comp]
        pyf_fname += comp
    else:
        os.chdir(pyemapsroot)
        raise ValueError("Error: build pyemaps build type: {comp}")
    
    os.system("make clean")

    os.system(makestr)

    # build spg standalone spg module
    os.system("make " + MAKE_LOOKUP['spg'])
    pyf_fname = 'spg_spgseek.pyf'
    try:
         os.path.exists(pyf_fname)

    except FileNotFoundError as e:
        os.chdir(pyemapsroot)
        raise ValueError("Error: compiling PYF file {pyf_fname} for: {spg}") 
    os.system("make " + MAKE_LOOKUP['spg'])

    # build scattering standalone module
    scatteringpyf = MAKE_LOOKUP['scattering']
    os.system("make " + scatteringpyf)
    pyf_fname = 'scattering_sct.pyf'
    try:
         os.path.exists(pyf_fname)

    except FileNotFoundError as e:
        os.chdir(pyemapsroot)
        raise ValueError("Error: compiling PYF file {pyf_fname} for: {scattering}") 
    os.system("make " + scatteringpyf)
    
    pyf_fn = os.path.join(emapsdir, pyf_fname)
    
    try:
         os.path.exists(pyf_fn)

    except FileNotFoundError as e:
        os.chdir(pyemapsroot)
        raise ValueError("Error: compiling PYF file {pyf_fn} for: {comp}") 

    set_cfg(comp)

    os.chdir(pyemapsroot)

def get_bversion(btest = True):
    '''
    get build version number dynamically from the repo
    using repo APIs and write the version to __verson__ file
    '''
    import requests, re, json
    MAX_VER_DIGIT = 10
    
    repo_url = test_pypi_url if btest else rel_pypi_url
    url = repo_url + '/pypi/pyemaps/json'

    response = requests.get(url)
    
    try:
        jresp = response.json()

    except json.decoder.JSONDecodeError as e:
        print(f"error: getting response from pypi api: {e.msg}")
        raise SystemExit(e)

    except requests.exceptions.RequestException as e:        
        raise SystemExit(e)

    rels = jresp['releases']

    # get the current release
    max_ver = '0.0.1'
    for k in rels.keys():
        # major, minor, sub = int(re.split('.', k))
        # if max_major
        if k > max_ver:
            max_ver = k
    # increment version number by 1
    print(f"releases max: {max_ver}")

    ver = re.split(r"\.", max_ver)
    
    if len(ver) != 3:
        raise ValueError("Error: version number validation error")
    
    major, minor, sub = ver
    print(f"existing releases: {major},{minor}, {sub}")

    mr = int(minor)
    mx = int(major)
    su = int(sub)

    if int(mr >= MAX_VER_DIGIT):
        mr %= MAX_VER_DIGIT

    ver_num = mx*MAX_VER_DIGIT**2 + mr*MAX_VER_DIGIT + su
    print(f"incremented releases: {ver_num}")
    # increment the version number
    ver_num += 1
    print(f"releases numer: {ver_num}")

    if ver_num > MAX_VER_DIGIT**3:
        raise ValueError(f"Error: version numbers are full")

    sver = str(ver_num)
    if mx == 0 and len(sver) == 2:
        sver = '0' + sver
    ssub = sver[2]
    sminor = sver[1] 
    smajor = sver[0]

    new_version = '.'.join([smajor, sminor, ssub])
    print(f"new releases: {new_version}")
    # exit()
    return new_version


def hideEMAPSPYFiles():
    '''
    hack to evade setup.py to pick up some .py files from
    emaps directory. manifest.in exclude for these files 
    does not seem to work
    '''
    from pathlib import Path
    # first change working directory to emaps from here
    currdir = Path(os.path.abspath(__file__)).parent.absolute()
    # currdir = os.path.dirname(os.path.realpath(__file__))
    print(f'Current dir in hideEMAPSFiles: {os.path.abspath(__file__)}, {currdir}')
    emapsdir = os.path.join(currdir, 'emaps')
    
    for f in os.listdir(emapsdir):
        fp = os.path.join(emapsdir, f)
        if os.path.isfile(fp) and f.endswith(".py"):
            if not f.endswith("__init__.py") and \
                not f.endswith("setup_diffract.py"):
                fn = Path(fp)
                fn.with_suffix('')
                fn_tmpext = fn.with_suffix('.emapspy')
                move(fn, fn_tmpext)
                print(f'hid: ', fn_tmpext)

def restoreEMAPSPYFiles():
    '''
    hack to evade setup.py to pick up some .py files from
    emaps directory. manifest.in exclude for these files 
    does not seem to work
    '''
    
    currdir = Path(os.path.abspath(__file__)).parent.absolute()
    emapsdir = os.path.join(currdir, 'emaps')
      
    for f in os.listdir(emapsdir):

        fp = os.path.join(emapsdir, f)

        if os.path.isfile(fp) and f.endswith(".emapspy"):
            fn = Path(fp)
            fn.with_suffix('')
            fn_tmpext = fn.with_suffix('.py')
            move(fn, fn_tmpext)
            print(f'restored: ', fn_tmpext)

def build_package(comp = 'dif', repo_test = True):
    '''
    Build the package
    Conponent configuration via PYEMAPS_JSON env variable
    '''
    
    clean()
    make_pyf(comp)

    print(f"####Begin building pyemaps package for {comp}...")

    hideEMAPSPYFiles()
    #  build the source distribution
    # os.system('python -m build -s')
    os.system('python -m build -s -n')

    #  build the wheel distribution (linrary build)
    # os.system('python -m build -w')
    os.system('python -m build -w -n')
    restoreEMAPSPYFiles()


def upload_package(bRelease = False, ver = None):

    repo_name = 'pypi' if bRelease else 'testpypi'
    cfg_fn = twine_cfg if bRelease else twinetest_cfg
    
    ul_cmd = 'python -m twine upload --repository ' + \
            repo_name + ' --config-file ' + cfg_fn + \
            ' dist/*'+ ver + '* --verbose'

    if bRelease:
        q = str(f"About to publish pyemaps v{ver} ") + \
            "to official public repository." + \
            "Are you sure? [Y|n]"
        ans = input(q).lower().strip()[:1]

        if ans == 'n':
            print(f"info: upload to {repo_name} canceled")
            return 0

        if ans == 'y' or ans == '':
            print(f"Uploading package to pypi.org: {ul_cmd}")
            os.system(ul_cmd)
            return 1
        else:
            raise ValueError(str(f"Invalid answer: {ans}"))

    else:
        print(f"Uploading package to test.pypi.org: {ul_cmd}")
        os.system(ul_cmd)
    return 1 #successful

def install_package(btest = True, ver= '0.0.0'):

    repo_url = ''
    if btest:
        repo_url ='-i ' + test_pypi_url + '/simple/'
    
    install_cmd = 'python -m pip install ' + repo_url + ' pyemaps=='+ver
    print(f'installation: {install_cmd}')
    os.system(install_cmd)

def install_local():
    import shutil

    LIBDIR = '.libs'

    pyemaps_dir = Path(os.path.abspath(__file__)).parent.absolute()
    print(f'pyemaps directoty {pyemaps_dir}')
    os.chdir(pyemaps_dir)

    # install_cmd = 'python -m pip install -e .'
    install_cmd = 'python -m pip install --no-build-isolation -e .'
    
    os.system(install_cmd)

    #also copy all sample code into parent directory
    samples_src_dir = os.path.join(pyemaps_dir, 'samples')
    sample_dest = pyemaps_dir.parent.absolute()

    print(f'sampme dirs: {samples_src_dir}, {sample_dest}')
    for f in os.listdir(samples_src_dir):
        src_file = os.path.join(samples_src_dir, f)
        print(f'source sample file name: {src_file}')
        if os.path.isfile(src_file):
            print(f'destination: {sample_dest}')
            shutil.copy(src_file, sample_dest)

    # copy a couple of files into its parent dir
    # sanity.bat
    sanity_src_dir = os.path.join(pyemaps_dir, 'test')
    sanity_src_dir = os.path.join(sanity_src_dir, 'sanity')

    for f in os.listdir(sanity_src_dir):
            src_file = os.path.join(sanity_src_dir, f)
            print(f'source sanity file name: {src_file}')
            if os.path.isfile(src_file):
                print(f'destination: {sample_dest}')
                shutil.copy(src_file, sample_dest)


if __name__ == "__main__":
    import argparse
    import time
    parser = argparse.ArgumentParser(description="Build and publish script for pyeamps")
    parser.add_argument("-c", "--component", type=str, nargs="?", const="dif", default="dif", help="build pyemaps component, defaults to dif module", required=False)
    parser.add_argument("-u", "--upload", action="store_true", help="upload the build or not", required=False)
    parser.add_argument("-t", "--test-repo", action="store_true", help="upload to the build to test repo test.pypi.org", required=False)
    parser.add_argument("-i", "--install", action="store_true", help="install the package from above repo", required=False)
    parser.add_argument("-nb", "--no-build", action="store_true", help="no build", required=False)
    parser.add_argument("-il", "--install-local", action="store_true", help="no build", required=False)
    parser.add_argument("-v", "--build-version", type=str, nargs="?", const="", default="", help="build version input", required=False)
    
    args = parser.parse_args()
    comp = args.component

    if not comp:
        # defaults to dif pyeamps module
        comp = 'bloch'

    ver = args.build_version
    if not ver or ver == '':
        ver = get_bversion(btest = args.test_repo)
    
    # write the version into __version__.py file
    with open('__version__.py', 'w') as vf:
        vf.write('__version__ = \"' + ver + '\"')

    if not args.no_build:
        build_package(comp)

    if args.install_local:
        install_local()
        exit(0)

    if not args.upload:
        exit(0)

    # upload the package
    ret = upload_package(bRelease = not args.test_repo , ver = ver)

    if ret ==0:
        # user canceled upload in case of release   
        exit(0)

    if not args.install or not args.install_local:
        exit(0)
    
    # wait for the upload is done 
    time.sleep(10)

    if args.install:
        install_package(btest = args.test_repo, ver=ver)
    

    
