from multiprocessing.sharedctypes import Value
import os
from shutil import move
from pathlib import Path

MAKE_LOOKUP = dict(
    dif = 'DIFPYF',
    bloch = 'BLOCHPYF',
    dpgen = 'CDPOBJ DPGENPYF',
    csf = 'CSFPYF',
    powder = 'POWDERPYF',
    spg = 'SPGSEEKPYF',
    scattering = 'SCTPYF',
    all = 'CDPOBJ ALLPYF'
)

test_pypi_url = "https://test.pypi.org"
rel_pypi_url = "https://pypi.org"
twine_cfg = 'pypi_twine.cfg'
twinetest_cfg = 'testpypi_twine.cfg'

def clean():
    '''
    remove build and dist directory in the pyemaps root directory
    '''
    import os, shutil
    from pathlib import Path
    
    builddir = Path("build")
    print(f"Build dir: {builddir}")
    if os.path.exists(builddir) and os.path.isdir(builddir):
        shutil.rmtree(builddir)


    distdir = Path('dist')
    print(f"Distribution dir: {distdir}")
    if os.path.exists(distdir) and os.path.isdir(distdir):
        shutil.rmtree(distdir)


    eggdir = Path('pyemaps.egg-info')
    print(f"Egg info dir: {eggdir}")
    if os.path.exists(eggdir) and os.path.isdir(eggdir):
        shutil.rmtree(eggdir)

def set_cfg(comp):
    import json, os

    json_cfg = os.getenv('PYEMAPS_JSON')

    if not json_cfg:
        json_cfg = "comp.json" # default

    # write a file recording the comp name for setup consumption
    
    json_obj = json.dumps(dict(component = comp))
    try:
        with open(json_cfg, 'w', encoding="utf-8") as f:
            f.write(json_obj)

    except IOError as e:
        raise ValueError(f"Error writing configuration file {json_cfg} for packaging")


def make_pyf(comp):
    '''
    make .pyf file according to comp name
    '''
    # first change working directory to emaps
    pyemapsroot = os.getcwd()
    os.chdir('emaps')
    emapsdir = os.getcwd()

    os.system("make clean")

    pyf_fname = 'emaps_'
    makestr = "make EMAPSALLMODULES"
    if comp in MAKE_LOOKUP:
        makestr += ' '
        makestr += MAKE_LOOKUP[comp]
        pyf_fname += comp
    else:
        os.chdir(pyemapsroot)
        raise ValueError("Error: build pyemaps build type: {comp}")
    
    os.system("make clean")

    os.system(makestr)

    # build spg standalone spg module
    os.system("make " + MAKE_LOOKUP['spg'])
    pyf_fname = 'spg_spgseek.pyf'
    try:
         os.path.exists(pyf_fname)

    except FileNotFoundError as e:
        os.chdir(pyemapsroot)
        raise ValueError("Error: compiling PYF file {pyf_fname} for: {spg}") 
    os.system("make " + MAKE_LOOKUP['spg'])

    # build scattering standalone module
    scatteringpyf = MAKE_LOOKUP['scattering']
    os.system("make " + scatteringpyf)
    pyf_fname = 'scattering_sct.pyf'
    try:
         os.path.exists(pyf_fname)

    except FileNotFoundError as e:
        os.chdir(pyemapsroot)
        raise ValueError("Error: compiling PYF file {pyf_fname} for: {scattering}") 
    os.system("make " + scatteringpyf)
    
    pyf_fn = os.path.join(emapsdir, pyf_fname)
    
    try:
         os.path.exists(pyf_fn)

    except FileNotFoundError as e:
        os.chdir(pyemapsroot)
        raise ValueError("Error: compiling PYF file {pyf_fn} for: {comp}") 

    set_cfg(comp)

    os.chdir(pyemapsroot)

def get_bversion(btest = True):
    '''
    get build version number dynamically from the repo
    using repo APIs and write the version to __verson__ file
    '''
    import requests, re, json
    MAX_VER_DIGIT = 10
    
    repo_url = test_pypi_url if btest else rel_pypi_url
    url = repo_url + '/pypi/pyemaps/json'

    response = requests.get(url)
    
    try:
        jresp = response.json()

    except json.decoder.JSONDecodeError as e:
        print(f"error: getting response from pypi api: {e.msg}")
        raise SystemExit(e)

    except requests.exceptions.RequestException as e:        
        raise SystemExit(e)

    rels = jresp['releases']

    # get the current release
    max_ver = '0.0.1'
    for k in rels.keys():
        # major, minor, sub = int(re.split('.', k))
        # if max_major
        if k > max_ver:
            max_ver = k
    # increment version number by 1
    print(f"releases max: {max_ver}")

    ver = re.split(r"\.", max_ver)
    
    if len(ver) != 3:
        raise ValueError("Error: version number validation error")
    
    major, minor, sub = ver
    
    ver_num = int(major)*MAX_VER_DIGIT**2 + int(minor)*MAX_VER_DIGIT + int(sub)
    # increment the version number
    print(f"releases numer: {ver_num}")
    ver_num += 1

    if ver_num > MAX_VER_DIGIT**3:
        raise ValueError(f"Error: version numbers are full")

    sub = ver_num % MAX_VER_DIGIT
    minor = ver_num // MAX_VER_DIGIT
    major = ver_num // MAX_VER_DIGIT**2

    new_version = '.'.join([str(major), str(minor), str(sub)])
    print(f"new releases: {new_version}")

    with open('__version__.py', 'w') as vf:
        vf.write('__version__ = \"' + new_version + '\"')

    return new_version


def hideEMAPSPYFiles():
    '''
    hack to evade setup.py to pick up some .py files from
    emaps directory. manifest.in exclude for these files 
    does not seem to work
    '''
    currdir = os.path.dirname(os.path.realpath(__file__))
    emapsdir = os.path.join(currdir, 'emaps')
    
    for f in os.listdir(emapsdir):
        fp = os.path.join(emapsdir, f)
        if os.path.isfile(fp) and f.endswith(".py"):
            if not f.endswith("__init__.py") and \
                not f.endswith("setup_diffract.py"):
                fn = Path(fp)
                fn.with_suffix('')
                fn_tmpext = fn.with_suffix('.emapspy')
                move(fn, fn_tmpext)
                print(f'hid: ', fn_tmpext)

def restoreEMAPSPYFiles():
    '''
    hack to evade setup.py to pick up some .py files from
    emaps directory. manifest.in exclude for these files 
    does not seem to work
    '''
    
    currdir = os.path.dirname(os.path.realpath(__file__))
    emapsdir = os.path.join(currdir, 'emaps')
      
    for f in os.listdir(emapsdir):

        fp = os.path.join(emapsdir, f)

        if os.path.isfile(fp) and f.endswith(".emapspy"):
            fn = Path(fp)
            fn.with_suffix('')
            fn_tmpext = fn.with_suffix('.py')
            move(fn, fn_tmpext)
            print(f'restored: ', fn_tmpext)

def build_package(comp = 'dif', repo_test = True):
    '''
    Build the package
    Conponent configuration via PYEMAPS_JSON env variable
    '''
    
    clean()
    make_pyf(comp)

    print(f"####Begin building pyemaps package for {comp}...")

    hideEMAPSPYFiles()
    #  build the source distribution
    os.system('python -m build -s')

    #  build the wheel distribution (linrary build)
    os.system('python -m build -w')
    restoreEMAPSPYFiles()


def upload_package(bRelease = False, ver = None):

    repo_name = 'pypi' if bRelease else 'testpypi'
    cfg_fn = twine_cfg if bRelease else twinetest_cfg
    
    ul_cmd = 'python -m twine upload --repository ' + \
            repo_name + ' --config-file ' + cfg_fn + \
            ' dist/*'+ ver + '* --verbose'

    if bRelease:
        q = str(f"About to publish pyemaps v{ver} ") + \
            "to official public repository." + \
            "Are you sure? [Y|n]"
        ans = input(q).lower().strip()[:1]

        if ans == 'n':
            print(f"info: upload to {repo_name} canceled")
            return 0

        if ans == 'y' or ans == '':
            print(f"Uploading package to pypi.org: {ul_cmd}")
            os.system(ul_cmd)
            return 1
        else:
            raise ValueError(str(f"Invalid answer: {ans}"))

    else:
        print(f"Uploading package to test.pypi.org: {ul_cmd}")
        os.system(ul_cmd)
    return 1 #successful

def install_package(btest = True, ver= '0.0.0'):

    repo_url = ''
    if btest:
        repo_url ='-i ' + test_pypi_url + '/simple/'
    
    install_cmd = 'python -m pip install ' + repo_url + ' pyemaps=='+ver
    print(f'installation: {install_cmd}')
    os.system(install_cmd)


if __name__ == "__main__":
    import argparse
    import time
    parser = argparse.ArgumentParser(description="Build and publish script for pyeamps")
    parser.add_argument("-c", "--component", type=str, nargs="?", const="dif", default="dif", help="build pyemaps component, defaults to dif module", required=False)
    parser.add_argument("-u", "--upload", action="store_true", help="upload the build or not", required=False)
    parser.add_argument("-t", "--test-repo", action="store_true", help="upload to the build to test repo test.pypi.org", required=False)
    parser.add_argument("-i", "--install", action="store_true", help="install the package from above repo", required=False)
    parser.add_argument("-nb", "--no-build", action="store_true", help="no build", required=False)
    # parser.add_argument("-n", "--no-build", action="store_true", help="No build", required=False)
    
    args = parser.parse_args()
    comp = args.component

    if not comp:
        # defaults to dif pyeamps module
        comp = 'dif'

    ver = get_bversion(btest = args.test_repo)
    
    if not args.no_build:
        build_package(comp)

    if not args.upload:
        exit(0)

    # upload the package
    ret = upload_package(bRelease = not args.test_repo , ver = ver)

    if ret ==0:
        # user canceled upload in case of release   
        exit(0)

    if not args.install:
        exit(0)
    
    # wait for the upload is done 
    time.sleep(10)
    install_package(btest = args.test_repo, ver=ver)
    

    
