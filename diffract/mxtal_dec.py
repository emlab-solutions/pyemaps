'''
.. This file is part of pyEMAPS
 
.. ----

.. pyEMAPS is free software. You can redistribute it and/or modify 
.. it under the terms of the GNU General Public License as published 
.. by the Free Software Foundation, either version 3 of the License, 
.. or (at your option) any later version..

.. pyEMAPS is distributed in the hope that it will be useful,
.. but WITHOUT ANY WARRANTY; without even the implied warranty of
.. MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.. GNU General Public License for more details.

.. You should have received a copy of the GNU General Public License
.. along with pyEMAPS.  If not, see `<https://www.gnu.org/licenses/>`_.

.. Contact supprort@emlabsoftware.com for any questions and comments.

.. ----


Author:             EMLab Solutions, Inc.
Date Created:       May 07, 2022  

'''
def add_mxtal(target):
    from . import dif
    from .. import (ID_MATRIX, MLEN, DEF_CELLBOX, 
                   DEF_XZ, DEF_ORSHIFT, DEF_TRSHIFT,
                   DEF_LOCASPACE)
    from .. import MxtalError
    from ..fileutils import compose_ofn
    from ..xtal import Xtal
    
    @staticmethod
    def printXYZ( mx):
        '''
        Print mxtal data in .xyz format in standard output. 
        Refer to `XYZ format <https://wiki.jmol.org/index.php/File_formats/Formats/XYZ>`_
        for its definition and usage.
        
        :param mx: Crystal structure object defined in xtal.py defiend as Xtal. 
        :type mx: Xtal, required

        .. note:: An example of Silicon atomic structure by pyemaps:
            
        .. code-block:: console

            216
                50.0 50.0 50.0 90.0 90.0 90.0
            SI        	 0.6788375000   0.6788375000   0.6788375000 
            SI        	 3.3941875000   3.3941875000   0.6788375000 
            SI        	 4.7518625000   2.0365125000   2.0365125000 
            SI        	 2.0365125000   4.7518625000   2.0365125000 
            SI        	 3.3941875000   0.6788375000   3.3941875000 
            ...

        '''
        if not isinstance(mx, Xtal): 
            raise MxtalError("The print object is not valid atomic structure object.")
        print(f'{str(mx)}')

    def writeXYZ(self, mx, fn=None):
        '''
        Save crystal structure object data generated by pyemaps to a .xyz file <fn>
        File path is composed by pyemaps depending on whether 
        PYEMAP_DATA environment variable is set. For details how
        *pyemaps* compose the file name see 
        :ref:`Environment Variables <Environment Variables>`
        for details.
        
        The file can be imported into external tool such as Jmole to
        view its content. 
        

        '''
        
        if not isinstance(mx, Xtal): 
            raise MxtalError("The print object is not valid atomic structure object.")
        
        # slines = []
        # nxyz = len(xyzlist)

        xyzfn = compose_ofn(fn, self.name, ty='mxtal') +'.xyz'
        
        try:
            with open(xyzfn, 'w') as f:
                # slines.append(str(nxyz))      
                # c0, c1, c2, c3, c4, c5 = xyzdict['cell']
                # slines.append(str(f'\t {c0} {c1} {c2} {c3} {c4} {c5}'))
                # for xyz in xyzlist:
                #     s, x, y, z = xyz['symb'], xyz['coord'][0], xyz['coord'][1], xyz['coord'][2]
                #     sx = '{0:<#014.10f}'. format(x)
                #     sy = '{0:<#014.10f}'. format(y)
                #     sz = '{0:<#014.10f}'. format(z)
                    
                #     slines.append(str(f'{s:<10}\t{sx} {sy} {sz}'))
                f.writelines(str(mx))
        except (FileNotFoundError, IOError, PermissionError) as e:
            print(f'Error writing xyz data file {fn}')
            return -1
        except Exception:
            return -1
        else:
            print(f'Successfully saved mxtal data in file: {xyzfn}')
            return 0

    def generateMxtal(self, 
                      trMatrix = ID_MATRIX, 
                      trShift = DEF_TRSHIFT, #Transformation shift
                      cellbox = DEF_CELLBOX,
                      xz = DEF_XZ,
                      orShift = DEF_ORSHIFT, #Origin shift
                      locASpace = DEF_LOCASPACE,
                      bound = None): #location in A Space
        """
        Generate the crystal atomic structure data in .xyz format.

        :param trMatrix: Transformation matrix
        :type trMatrix: array, optional

        :param trShift: Transformation shift
        :type trShift: array, optional

        :param cellbox: Locate atoms inside a box defined. 
        :type cellbox: array, optional

        :param xz: X and Z orientations in real space. 
        :type xz: array, optional

        :param orShift: Origin shift. 
        :type orShift: float, optional

        :param locASpace: Locate atoms inside a box defined. 
        :type locASpace: array, optional

        :param bound: Location in A Space. 
        :type bound: float, optional
        
        :return: a python dictionary object of cell constants and 3D coordinates of atoms
        :rtype: dict

        Example of the .xyz data in python dictionary object:
        
        .. code-block::

            {
                xyz: [(syml1,[x1, y1, z1)]...[(symln, xn, yn, zn)]]
                cell: [...] #transformed cell constants
            }

        """
        import numpy as np
        from numpy import asfortranarray as farray
        from . import mxtal as MX

        dif.initcontrols()
        
        self.load(cty=1)
            
        tmat = farray(np.array(trMatrix))
        
        pxz = farray(np.array(xz))

        if bound is not None:
            ret = MX.do_mxtal(tmat, trShift, cellbox[0], cellbox[1],
                            pxz[0], pxz[1], orShift, locASpace, bound)
        else:
            ret = MX.do_mxtal(tmat, trShift, cellbox[0], cellbox[1],
                            pxz[0], pxz[1], orShift, locASpace)
        
        if ret != 1:
            raise MxtalError('Failed to starting mxtal module')
        
        na = MX.get_nxyz()
        
        if na <=0:
            raise MxtalError('Failed to generate data')

        xyz, ret = MX.get_xyzdata(na)
    
        if ret != 1:
            raise MxtalError('Failed to retrieve data')

        sym = farray(np.empty((MLEN, na), dtype='c'))
        sym, ret = MX.get_symdata(sym)
    
        if ret != 1:
            raise MxtalError('Failed to retrieve data')

        tsym = np.transpose(sym)
        txyz = np.transpose(xyz)
        
        mx = Xtal()
        for i in range(na):          
            s = bytearray(tsym[i]).decode('utf-8').strip(" \x00")
            
            # print(f'type of coordinate: {type(txyz[i])}')
            mx.add(s, txyz[i])

        nc = 6
        cell, ret = MX.get_cellconst(nc)
        # print(f'Cell constants: {cell}')
        mx.cell = cell

        if ret !=0:
            raise MxtalError(f'Failed to retrieve cell constants: {ret}')

        # clean up
        MX.cleanup()
        return mx

    target.generateMxtal = generateMxtal
    target.printXYZ = printXYZ
    target.writeXYZ =writeXYZ
    return target
