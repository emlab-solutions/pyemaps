
def run_si_sample(ty = 2):
    from pyemaps import Crystal as cr
    import os
    import time
    from pyemaps import CrystalClassError

    #CIF_DIR = "C:/Apps/Python37/Lib/site-packages/crystals/cifs"
    CIF_DIR = "C:/Users/employee1/Downloads/drawxtl/cifs"
    XTL_DIR = "C:/Apps/Python37/Lib/site-packages/pyemaps/cdata"
    cif_ext = '.cif'
    xtl_ext = '.xtl'

    failure_count = 0
    if ty == 1:
        ext = xtl_ext
        datadir = XTL_DIR
    else:
        ext = cif_ext
        datadir = CIF_DIR
    
    failure_cases = []
    for f in os.listdir(datadir):
        
        if f.endswith(ext):
            cfn = os.path.join(datadir, f)
            print(f'\n+++++++\nLoading {cfn}...')
            cf = None
            try:    
                if ty == 1:
                    
                    cf = cr.from_xtl(cfn) 
                else:        
                    tic = time.perf_counter()
                    cf = cr.from_cif(cfn)
                    toc = time.perf_counter()
                    print(f"Time it takes for loading {f} in {toc - tic:0.4f} seconds")
            except CrystalClassError as v:
                print(f'%%%%%%%Loading {cfn} failed with message: {v}')
                failure_count += 1
                failure_cases.append(f)
                continue
            else:
                print(cf)
                # _, cf_dp = cf.generateDP()
               
                # # print the diffraction pattern using the builtin format
                # print(f'Diffraction Pattern printout with builtin stdout:\n{cf_dp}\n\n')

                # # get the raw diffraction pattern in python dictionary 
                # # in case you want to import DP in your own program
                # dp_dict = cf_dp.__dict__
                # print(f'Raw diffraction pattern in python dictionary:\n{dp_dict}\n\n')
                
                # # or the raw data of each components of kinematic diffraction pattern 
                # # into your program and/or print them out
                # print(f'# of Kikuchi lines: {cf_dp.nklines}\nKikuchi lines list:\n{cf_dp.klines}\n\n')
                # print(f'# of diffracted beams (a.k.a Disks): {cf_dp.ndisks}\ndiffracted beams list:\n{cf_dp.disks}\n\n')
                # print(f'# of HOLZ lines: {cf_dp.nhlines}\nHOLZ lines list:\n{cf_dp.hlines}')
                # # cf_dp.plot()
                # # print(f"-------Loading {cfn} succeeded: \n{cf}")

    if failure_count == 0:
        print(f'***********Test Summary: All tests succeeded')
    else:
        print(f'Summary: total failure runs: {failure_count}')
        print(f'Failure cases list: {failure_cases}')
        # for f in failure_cases:
        #     cfn = os.path.join(datadir, f)
        #     print(f'\n+++++++\Loading failure cases {cfn}...')
        #     try:    
        #         if ty == 1:
        #             cf = cr.from_xtl(cfn) 
        #         else:        
        #             # tic = time.perf_counter()
        #             cf = cr.from_cif(cfn)
        #             # toc = time.perf_counter()
        #             # print(f"Time it takes for loading {f} in {toc - tic:0.4f} seconds")
        #     except CrystalClassError as v:
        #         print(f'********Loading {cfn} failed with message: {v}')
    
    # _, eu_dp = eu.generateDP()
    # #plot and show the diffraction pattern using pyemaps built-in plot function
    # eu_dp.plot()
def run_metrics():
    from pyemaps import Crystal as cr
    si = cr.from_builtin('Silicon')
    
    vd = si.d2r()
    print(f'\nDefault real space to reciprocal space transform: \n{vd}')
    vd = si.r2d()
    print(f'\nDefault reciprocal space to real space transform: \n{vd}')

    # real to reciprocal transformation
    v = (1.0, 1.0, 2.0)
    v_recip = si.d2r(v) 
    print(f'\nReal space to reciprocal space transform for {v}:\n{v_recip}')
  
    
    #reciprocal to real transformation
    v_ = si.r2d(v_recip) # v_ ~= v
    print(f'\nReciprocal space to real space transform for {v_recip}:\n{v_}')

    #angle in real space
    v1 = (1.0, 1.0, 2.0)
    v2 = (1.0, 1.0, 1.0)
    real_a = si.angle(v1, v2)
    print(f'\nAngle in real space by vectors {v1} and {v2}: \n{real_a} \u00B0')

    #angle in reciprocal space
    recip_a = si.angle(v1, v2, type = 1)
    print(f'\nAngle in reciprocal space by vectors {v1} and {v2}: \n{recip_a} \u00B0')

    #vector length in real space
    r_vlen = si.vlen(v)
    print(f'\nLength in real space for vector {v}:\n{r_vlen} in \u212B')

    #vector length in reciprocal space
    recip_vlen = si.vlen(v, type = 1)
    print(f'\nLength in reciprocal space for vector {v}:\n{recip_vlen} in 1/\u212B')

    #wave length with high voltage of 200 V
    print(f'\nWave length with high voltage of 200 kV:\n{si.wavelength(200)} \u212B')


if __name__ == '__main__':

    run_si_sample()
    run_si_sample(1)
    run_metrics()
