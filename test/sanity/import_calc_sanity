
from pyemaps.display import showBloch


def get_builtin_dir():
    import pyemaps
    from pathlib import Path

    return(Path(pyemaps.__file__).parent.absolute())

def run_si_difs(ty = 2):
    from pyemaps import Crystal as cr
    import os
    import time
    from pyemaps import CrystalClassError, DPList, showDif

    #CIF_DIR = "C:/Apps/Python37/Lib/site-packages/crystals/cifs"
    CIF_DIR = "C:/Users/sharon/dev_space/Downloads/cod-cifs-mysql/cif/1/01/01"
    XTL_DIR = os.path.join(get_builtin_dir(), "cdata")
    cif_ext = '.cif'
    xtl_ext = '.xtl'

    failure_count = 0
    if ty == 1:
        ext = xtl_ext
        datadir = XTL_DIR
    else:
        ext = cif_ext
        datadir = CIF_DIR
    
    failure_cases = []
    total_count = 0
    for f in os.listdir(datadir):
        
        if f.endswith(ext):
            cfn = os.path.join(datadir, f)
            total_count += 1
            print(f'\n+++++++\nLoading {cfn}...')
            cf = None
            try:    
                if ty == 1:                    
                    cf = cr.from_xtl(cfn) 
                else:        
                    tic = time.perf_counter()
                    cf = cr.from_cif(cfn)
                    toc = time.perf_counter()
                    print(f"Time it takes for loading {f} in {toc - tic:0.4f} seconds")
            except CrystalClassError as v:
                print(f'%%%%%%%Loading {cfn} failed with message: {v}')
                failure_count += 1
                failure_cases.append(f)
                continue
            else:
                print(cf)
                try:
                    emc, cf_dp = cf.generateDP()
                    dpl = DPList(cf.name)
                    dpl.add(emc, cf_dp)
                except:
                    failure_count += 1
                    failure_cases.append(f)
                    continue
                showDif(dpl, ishow=False)
                
                # # cf_dp.plot()
                # # print(f"-------Loading {cfn} succeeded: \n{cf}")

    if failure_count == 0:
        print(f'***********Test Summary: All tests succeeded')
    else:
        print(f'Summary: total failure runs: {failure_count} out of {total_count} runs')
        print(f'Failure cases list: {failure_cases}')
        # for f in failure_cases:
        #     cfn = os.path.join(datadir, f)
        #     print(f'\n+++++++\Loading failure cases {cfn}...')
        #     try:    
        #         if ty == 1:
        #             cf = cr.from_xtl(cfn) 
        #         else:        
        #             # tic = time.perf_counter()
        #             cf = cr.from_cif(cfn)
        #             # toc = time.perf_counter()
        #             # print(f"Time it takes for loading {f} in {toc - tic:0.4f} seconds")
        #     except CrystalClassError as v:
        #         print(f'********Loading {cfn} failed with message: {v}')
    
    # _, eu_dp = eu.generateDP()
    # #plot and show the diffraction pattern using pyemaps built-in plot function
    # eu_dp.plot()

def run_si_bloch(ty = 2):
    from pyemaps import Crystal as cr
    import os
    import time
    from pyemaps import CrystalClassError, DPList, showDif

    #CIF_DIR = "C:/Apps/Python37/Lib/site-packages/crystals/cifs"
    CIF_DIR = "C:/Users/sharon/dev_space/Downloads/cod-cifs-mysql/cif/1/01/01"
    XTL_DIR = os.path.join(get_builtin_dir(), "cdata")
    cif_ext = '.cif'
    xtl_ext = '.xtl'

    failure_count = 0
    if ty == 1:
        ext = xtl_ext
        datadir = XTL_DIR
    else:
        ext = cif_ext
        datadir = CIF_DIR
    
    failure_cases = []
    total_count = 0
    for f in os.listdir(datadir):
        
        if f.endswith(ext):
            cfn = os.path.join(datadir, f)
            total_count += 1
            print(f'\n+++++++\nLoading {cfn}...')
            cf = None
            try:    
                if ty == 1:                    
                    cf = cr.from_xtl(cfn) 
                else:        
                    tic = time.perf_counter()
                    cf = cr.from_cif(cfn)
                    toc = time.perf_counter()
                    print(f"Time it takes for loading {f} in {toc - tic:0.4f} seconds")
            except CrystalClassError as v:
                print(f'%%%%%%%Loading {cfn} failed with message: {v}')
                failure_count += 1
                failure_cases.append(f)
                continue
            else:
                print(cf)
                try:                   
                    tic = time.perf_counter()
                    bimgs= cf.generateBlochImgs(disk_size = 0.1, sample_thickness = (200, 200, 100))
                    toc = time.perf_counter()
                except:
                    failure_count += 1
                    failure_cases.append(f)
                    continue
                showBloch(bimgs)
                
                # # cf_dp.plot()
                print(f"-------generating bloch for {cfn} succeeded with time: {toc - tic:0.4f}")

    if failure_count == 0:
        print(f'***********Test Summary: All tests succeeded')
    else:
        print(f'Summary: total failure runs: {failure_count} out of {total_count} runs')
        print(f'Failure cases list: {failure_cases}')
        # for f in failure_cases:
        #     cfn = os.path.join(datadir, f)
        #     print(f'\n+++++++\Loading failure cases {cfn}...')
        #     try:    
        #         if ty == 1:
        #             cf = cr.from_xtl(cfn) 
        #         else:        
        #             # tic = time.perf_counter()
        #             cf = cr.from_cif(cfn)
        #             # toc = time.perf_counter()
        #             # print(f"Time it takes for loading {f} in {toc - tic:0.4f} seconds")
        #     except CrystalClassError as v:
        #         print(f'********Loading {cfn} failed with message: {v}')
    
    # _, eu_dp = eu.generateDP()
    # #plot and show the diffraction pattern using pyemaps built-in plot function
    # eu_dp.plot()
def run_metrics():
    from pyemaps import Crystal as cr
    si = cr.from_builtin('Silicon')
    
    vd = si.d2r()
    print(f'\nDefault real space to reciprocal space transform: \n{vd}')
    vd = si.r2d()
    print(f'\nDefault reciprocal space to real space transform: \n{vd}')

    # real to reciprocal transformation
    v = (1.0, 1.0, 2.0)
    v_recip = si.d2r(v) 
    print(f'\nReal space to reciprocal space transform for {v}:\n{v_recip}')
  
    
    #reciprocal to real transformation
    v_ = si.r2d(v_recip) # v_ ~= v
    print(f'\nReciprocal space to real space transform for {v_recip}:\n{v_}')

    #angle in real space
    v1 = (1.0, 1.0, 2.0)
    v2 = (1.0, 1.0, 1.0)
    real_a = si.angle(v1, v2)
    print(f'\nAngle in real space by vectors {v1} and {v2}: \n{real_a} \u00B0')

    #angle in reciprocal space
    recip_a = si.angle(v1, v2, type = 1)
    print(f'\nAngle in reciprocal space by vectors {v1} and {v2}: \n{recip_a} \u00B0')

    #vector length in real space
    r_vlen = si.vlen(v)
    print(f'\nLength in real space for vector {v}:\n{r_vlen} in \u212B')

    #vector length in reciprocal space
    recip_vlen = si.vlen(v, type = 1)
    print(f'\nLength in reciprocal space for vector {v}:\n{recip_vlen} in 1/\u212B')

    #wave length with high voltage of 200 V
    print(f'\nWave length with high voltage of 200 kV:\n{si.wavelength(200)} \u212B')


if __name__ == '__main__':

    run_si_difs() 
    run_si_difs(1)
    run_si_bloch(1)
    run_si_bloch() 
    run_metrics()